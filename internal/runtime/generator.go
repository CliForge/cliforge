package runtime

import (
	"bytes"
	"fmt"
	"go/format"
	"text/template"

	"github.com/CliForge/cliforge/pkg/cli"
)

// Generator generates runtime code for CLIs.
type Generator struct {
	config *cli.Config
}

// NewGenerator creates a new Generator.
func NewGenerator(config *cli.Config) *Generator {
	return &Generator{config: config}
}

// GenerateMain generates the main.go file for a CLI.
func (g *Generator) GenerateMain(configData []byte) (string, error) {
	tmpl := template.Must(template.New("main").Parse(mainGoTemplate))

	data := map[string]interface{}{
		"CLIName":     g.config.Metadata.Name,
		"Version":     g.config.Metadata.Version,
		"HasBranding": g.config.Branding != nil && g.config.Branding.ASCIIArt != "",
		"ASCIIArt":    "",
	}

	if g.config.Branding != nil && g.config.Branding.ASCIIArt != "" {
		data["ASCIIArt"] = g.config.Branding.ASCIIArt
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, return unformatted code with error context
		return "", fmt.Errorf("failed to format generated code: %w\n%s", err, buf.String())
	}

	return string(formatted), nil
}

const mainGoTemplate = `// Code generated by CliForge v0.9.0. DO NOT EDIT.

package main

import (
	_ "embed"
	"fmt"
	"os"

	"github.com/CliForge/cliforge/internal/runtime"
)

//go:embed config_embedded.yaml
var embeddedConfig []byte

var (
	version = "{{.Version}}"
	debug   = "false"
)

func main() {
	{{if .HasBranding}}
	// Display ASCII art banner
	fmt.Fprintln(os.Stderr, ` + "`" + `{{.ASCIIArt}}` + "`" + `)
	fmt.Fprintln(os.Stderr, "")
	{{end}}

	// Initialize runtime
	rt, err := runtime.NewRuntime(embeddedConfig, version, debug == "true")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to initialize: %v\n", err)
		os.Exit(1)
	}

	// Execute CLI
	if err := rt.Execute(); err != nil {
		os.Exit(1)
	}
}
`
