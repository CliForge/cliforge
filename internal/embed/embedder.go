// Package embed handles embedding configuration into generated CLI binaries.
package embed

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"text/template"
)

// Embedder generates code to embed configuration into binaries.
type Embedder struct {
	// Additional configuration can go here
}

// NewEmbedder creates a new Embedder instance.
func NewEmbedder() *Embedder {
	return &Embedder{}
}

// WriteEmbeddedConfig writes configuration data to a file for embedding.
func (e *Embedder) WriteEmbeddedConfig(configData []byte, outputPath string) error {
	return os.WriteFile(outputPath, configData, 0644)
}

// GenerateEmbedCode generates Go code that embeds the configuration.
func (e *Embedder) GenerateEmbedCode(configData []byte) (string, error) {
	tmpl := `// Code generated by CliForge. DO NOT EDIT.

package main

import "embed"

//go:embed config_embedded.yaml
var embeddedFS embed.FS

const embeddedConfigPath = "config_embedded.yaml"
`

	return tmpl, nil
}

// GenerateMainTemplate generates the main.go template with embedded config.
func (e *Embedder) GenerateMainTemplate(cliName, version string, configData []byte) (string, error) {
	tmpl := template.Must(template.New("main").Parse(mainTemplate))

	var buf bytes.Buffer
	err := tmpl.Execute(&buf, map[string]interface{}{
		"CLIName": cliName,
		"Version": version,
	})
	if err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return "", fmt.Errorf("failed to format generated code: %w", err)
	}

	return string(formatted), nil
}

const mainTemplate = `// Code generated by CliForge. DO NOT EDIT.

package main

import (
	_ "embed"
	"fmt"
	"os"

	"github.com/CliForge/cliforge/internal/runtime"
)

//go:embed config_embedded.yaml
var embeddedConfig []byte

var (
	version = "{{.Version}}"
	debug   = "false"
)

func main() {
	// Initialize runtime
	rt, err := runtime.NewRuntime(embeddedConfig, version, debug == "true")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to initialize: %v\n", err)
		os.Exit(1)
	}

	// Execute CLI
	if err := rt.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
`
